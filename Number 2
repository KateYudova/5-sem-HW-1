
#нумерация списка начинается с единицы, список однонаправленный
class Node: # звено
    def __init__(self, value = None, next = None):
        self.value = value
        self.next = next
        
class LinkList: # список
    def __init__(self):
        self.first = None
        self.last = None
        self.length = 0
        
    def __str__ (self): 
        if self.first != None:
            current = self.first
            out = 'LinkList [ ' + str(current.value)
            while current.next != None:
                out = out + ', '
                current = current.next
                out = out + str(current.value)
            out = out + ' ]'
            return out
        return 'LinkList []'
    def clear(self): 
            self.__init__()
    def add(self, x, y): #добавление звена на любую позицию, x - значение,y - позиция 
        self.length = self.length + 1
        if self.first == None:
            self.last = self.first = Node (x, None)
            return
        elif y == 1:
            self.first = Node(x, self.first)
            return
        current = self.first
        count = 0
        if 1 < y < self.length:
            while current != None:
                count +=1
                if count + 1 == y:
                    current.next = Node(x, current.next)
                    break
                current = current.next
        elif y == -1: # у = -1 признак того, что звено надо добавлять в конец
            self.last.next = self.last = Node(x, None)
        else : 
            self.last.next = self.last = Node(x, None)
    def dele(self, y): #удаление звена с любой позиции
        if self.first == None:
            return
        self.length = self.length - 1
        current = self.first
        if y == 1:
            self.first = current.next
            return
        elif y <= self.length + 1:
            count = 0
            precur = current
            while current != None:
                count +=1
                if count == y and y != self.length + 1:
                    precur.next = current.next
                elif count == self.length + 1:
                    self.last = precur
                    precur.next = None
                    break
                precur = current
                current = current.next
    def searc (self, x): #поиск первого вхождения 
        if self.first == None:
            return None
        current = self.first
        while current != None:
            if current.value == x:
                return current
            current = current.next
def formation (x):
    k = LinkList()
    while x != 0:
        c = x % 10
        k.add(c,-1)
        x = x //10
    return k
  
def sum (f, s):
    flag = 0
    l = LinkList()
    fcurr = f.first
    scurr = s.first
    while fcurr != None and scurr != None:
        t = fcurr.value + scurr.value + flag
        if t < 10:
            flag = 0
            l.add(t, -1)
        else:
            flag = 1
            l.add(t % 10, -1)
        fcurr = fcurr.next
        scurr = scurr.next
    while fcurr != None:
        t = fcurr.value + flag
        if t < 10:
            flag = 0
            l.add(t, -1)
        else:
            flag = 1
            l.add(t % 10, -1)
        fcurr = fcurr.next
    while scurr != None:
        t = scurr.value + flag
        if t < 10:
            flag = 0
            l.add(t, -1)
        else:
            flag = 1
            l.add(t % 10, -1)
        scurr = scurr.next
    if flag == 1:
        l.add(flag, -1)
    return l
            
#пример для проверки функций
a = int(input())
b = int(input())
l = LinkList()
m = LinkList()
l = formation(a)
m = formation(b)
c = sum (m,l)
print ("первое число в виде списка")
print (l)
print ("второе число в виде списка")
print (m)
print ("сумма списков: ")
print (c)
